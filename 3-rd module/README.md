## Problem inf-II-01-0: posix/threads/simple-create-join

На стандартном потоке ввода задается последовательность целых чисел.

Необходимо прочитать эти числа, и вывести их в обратном порядке.

Каждый поток может прочитать или вывести только одно число.

Используйте многопоточность, запуск процессов запрещен.
___
## Problem inf-II-01-1: posix/threads/parallel-sum

Единственным аргументом программы является целое число N>1 - число потоков, которые нужно создать.

На стандартном потоке ввода задается последовательность целых чисел.

Реализуйте программу, которая запускает N потоков, каждый из которых читает числа со стандартного потока ввода, и вычисляет частичные суммы. Учтите, что количество потоков необязательно равно количеству чисел.

На стандартный поток вывода необходимо вывести итоговую сумму всех чисел.

Минимизируйте объем используемой памяти настолько, насколько это возможно. Обратите внимание на ограничение по памяти.
___
## Problem inf-II-01-2: posix/threads/ping-pong-threads-socketpair

Программе передается единственный аргумент - начальное значение 0<N≤100.

Необходимо создать два потока:

1. Принимает число, уменьшает его значение на 3, выводит его на стандартный поток вывода, и передает другому потоку.
2. Принимает число, увеличивает его значение на 5, выводит его на стандартный поток вывода, и передает другому потоку.

Начально значение передается первому потоку.

Взаимодействие прекращается, когда значение будет равно 0, либо станет строго больше 100. Последний поток, который получит число 0 или число >100, должен вывести его на стандартный поток вывода, и завершить работу.

Для передачи чисел между потоками используйте пару сокетов (man socketpair).
___
## Problem inf-II-02-0: posix/threads/mutex

Программа запускается с двумя целочисленными аргументами: N>0 - количество итераций; и k>0 - количество потоков.

Необходимо создать массив из k вещественных чисел, после чего запустить k потоков, каждый из которых работает со своим элементом массива и двумя соседними.

Каждый поток N раз увеличивает значение своего элемента на 1, увеличивает значение соседа слева на 0.99, и увеличивает значение соседа справа на 1.01.

Для потоков, у которых нет соседей справа (k-1) или слева (0), соседними считать первое и последнее значение массива соответственно.

После того, как все потоки проведут N итераций, необходимо вывести значения всех элементов.

Запрещено использовать глобальные переменные.

Для вывода используйте формат %.10g.
___
## Problem inf-II-02-1: posix/threads/condvar

Программа принимает три аргумента: два 64-битных числа A и B, и 32-битное число N.

Затем создается дополнительный поток, которые генерирует простые числа в диапазоне от A до B включительно, и сообщает об этом основному потоку, с которого началось выполнение функции main.

Главный поток выводит на стандартный поток вывода каждое полученное число и завершает свою работу после того, как получит N чисел.

Запрещено использовать глобальные переменные.
___
## Problem inf-II-02-2: posix/threads/atomic

Реализуйте Lock-Free односвязный список из элементов:

    typedef struct Item {
    struct Item *next;
    int64_t      value;
    } item_t;

Программа принимает в качестве аргумента значения N - количество потоков, и k - количество элементов, создаваемых каждым потоком.

Этих потоков может быть очень много - несколько десятков!

Каждый поток должен добавить в односвязный список k элементов со значениями от i*k до (i+1)*k, где i - это номер потока от 0 до N.

После завершения работы всех потоков выведите все значения полученного односвязного списка.

Запрещено использовать мьютексы, семафоры или активное ожидание.

Минимизируйте используемый объем памяти.

Для уменьшения времени простоя используйте sched_yield в конце каждой итерации.
___
## Problem inf-II-03-0: posix/pipe/launch

Реализуйте программу, которая принимает два аргумента: CMD - команда для запуска, IN - имя файла, направляемого на ввод.

Программа должна запускать указанную команду, передавая ей на вход содежимое файла IN.

На стандартный поток вывода вывести количество байт, которое было записано запущенной командой в стандартный поток вывода. Вывод самой команды никуда выводить не нужно.
___
## Problem inf-II-03-1: posix/pipe/connect-2-processes

Программе передаётся два аргумента: CMD1 и CMD2. Необходимо запустить два процесса, выполняющих эти команды, и перенаправить стандартный поток вывода CMD1 на стандартный поток ввода CMD2.

В командной строке это эквивалентно CMD1 | CMD2.

Родительский процесс должен завершаться самым последним!
___
## Problem inf-II-03-3: posix/pipe/connect-n-processes

Программе передаётся произвольное количество аргументов: CMD1, CMD2, ..., CMDN.

Необходимо реализовать эквивалент запуска их командной строки: CMD1 | CMD2 | ... | CMDN.

Родительский процесс должен завершаться самым последним!
___
## Problem inf-II-04-0: posix/signals/count-sigint

Программа при запуске сообщает на стандартный поток вывода свой PID, выталкивает буфер вывода с помощью __fflush__, после чего начинает обрабатывать поступающие сигналы.

При поступлении сигнала SIGTERM необходимо вывести на стандартный поток вывода целое число: количество ранее поступивших сигналов SIGINT и завершить свою работу.

Семантика повединия сигналов (Sys-V или BSD) считается не определенной.
___ 
## Problem inf-II-04-1: posix/signals/do-actions

Программа при запуске сообщает на стандартный поток вывода свой PID, после чего читает со стандартного потока ввода целое число - начальное значение, которое затем будет изменяться.

При поступлении сигнала SIGUSR1 увеличить текущее значение на 1 и вывести его на стандартный поток вывода.

При поступлении сигнала SIGUSR2 - умножить текущее значение на -1 и вывести его на стандартный поток вывода.

При поступлении одного из сигналов SIGTERM или SIGINT необходимо завершить свою работу с кодом возврата 0.

Семантика повединия сигналов (Sys-V или BSD) считается не определенной.

Не забывайте выталкивать буфер вывода.
___
## Problem inf-II-04-2: posix/signals/signalfd-rtsig

Программе в качестве аргументов передаются N имен текстовых файлов.

Программа должна обрабатывать множество сигналов от SIGRTMIN до SIGRTMAX, причем номер сигнала в диапазоне от SIGRTMIN+1 определяет порядковый номер файла из аргументов:

    x = signo - SIGRTMIN; // SIGRTMIN <= signo <= SIGRTMAX
                        // 1 <= x <= SIGRTMAX-SIGRTMIN

При получении очередного сигнала необходимо прочитать одну строку из определенного файла и вывести её на стандартный поток вывода.

При получении сигнала с номером SIGRTMIN, т.е. при номере аргумента, равным 0, - корректно завершить свою работу с кодом 0.

Все остальные сигналы нужно игнорировать.

Если для вывода используются высокоуровневые функции стандартной библиотеки Си, то необходимо выталкивать буфер обмена после вывода каждой строки.
___
## Problem inf-II-04-3: posix/signals/ping-pong-using-signals

Программа обрабатывать сигнал SIGRTMIN, вместе с которым передается некоторое беззнаковой 32-битное целое число N.

Все остальные сигналы нужно игнорировать.

При получении очередного сигнала нужно уменьшить это число на единицу и отправить его обратно тому процессу, который его послал (используя тот же самый сигнал).

Взаимодействие останавливается при получении значения N==0, после чего нужно корректно завершить работу.

Запрещается использовать signalfd, программа будет компилироваться без поддержки Linux-специфичных расширений.
___
## Problem inf-II-05-0: posix/sockets/tcp-client

Программе передаются два аргумента: строка с IPv4-адресом в стандартной десятичной записи (четыре числа, разделенные точкой), и номер порта.

Программа должна установить соединение с указанным сервером, после чего читать со стандартного потока ввода целые знаковые числа в текстовом формате, и отправлять их в бинарном виде на сервер. Порядок байт - Little Endian.

В ответ на каждое полученное число, сервер отправляет целое число (в таком же формате), и все эти числа необходимо вывести на стандартный поток вывода в текстовом виде.

Если сервер по своей инициативе закроет соединение, то нужно завершить работу с кодом возврата 0.
___ 
## Problem inf-II-05-1: posix/sockets/http-server-1

Необходимо реализовать программу-сервер, которой передаются два аргумента: номер порта и полный путь к каталогу с данными.

Программа должна прослушивать TCP-соединение на сервере localhost и указанным номером порта.

После получения сигнала SIGTERM или SIGINT сервер должен закончить обработку текущего соединения, если оно есть, после чего корректно завершить свою работу.

Внимание: в этой задаче признаком конца строк считается пара символов "\r\n", а не одиночный символ '\n'.

Каждое соединение должно обрабатываться следующим образом:

1. Клиент отправляет строку вида GET ИМЯ_ФАЙЛА HTTP/1.1
2. Клиент отправляет произвольное количество непустых строк
3. Клиент отправляет пустую строку

После получения пустой строки от клиента, сервер должен отправить клиенту слеющие данные:

1. Строку HTTP/1.1 200 OK, если файл существует, или HTTP/1.1 404 Not Found, если файл не существует, или HTTP/1.1 403 Forbidden, если файл существует, но не доступен для чтения
2. Строку Content-Length: %d, где %d - размер файла в байтах
3. Пустую строку
4. Содержимое файла as-is

После отправки ответа клиенту, нужно закрыть соединение и не нужно ждать ожидать от клиента следующих запросов.
___
## Problem inf-II-05-2: posix/sockets/http-server-2

Необходимо реализовать программу-сервер, которой передаются два аргумента: номер порта и полный путь к каталогу с данными.

Программа должна прослушивать TCP-соединение на сервере localhost и указанным номером порта.

После получения сигнала SIGTERM или SIGINT сервер должен закончить обработку текущего соединения, если оно есть, после чего корректно завершить свою работу. Если при этом были запущены дочерние процессы - они должны быть завершены самим сервером.

Внимание: в этой задаче признаком конца строк считается пара символов "\r\n", а не одиночный символ '\n'.

Каждое соединение должно обрабатываться следующим образом:

1. Клиент отправляет строку вида GET ИМЯ_ФАЙЛА HTTP/1.1
2. Клиент отправляет произвольное количество непустых строк
3. Клиент отправляет пустую строку

После получения пустой строки от клиента, сервер должен отправить клиенту слеющие данные:

- Строку HTTP/1.1 200 OK, если файл существует, или HTTP/1.1 404 Not Found, если файл не существует, или HTTP/1.1 403 Forbidden, если файл существует, но не доступен для чтения

Если файл не является выполняемым, то:

1. Строку Content-Length: %d, где %d - размер файла в байтах
2. Пустую строку
3. Содержимое файла as-is

Если файл является выполняемым, то после вывода строки HTTP/1.1 200 OK нужно выполнить этот файл, перенаправив его стандартный поток вывода клиенту as-is.

После отправки ответа клиенту, нужно закрыть соединение и не нужно ждать ожидать от клиента следующих запросов.
___
## Problem inf-II-06-0: posix/sockets/udp-client

Аргументом программы является целое число - номер порта на сервере localhost.

Программа читает со стандартного потока ввода целые числа в тектовом формате, и отправляет их в бинарном виде (little-endian) на сервер как UDP-сообщение.

В ответ сервер отправляет целое число (также в бинарном виде, little-endian), которое необходимо вывести на стандартный поток вывода.
___
## Problem inf-II-06-1: posix/sockets/icmp-ping

Программа принимает три аргумента: строку с IPv4-адресом, и два неотрицательных целых числа, первое из которых определяет общее время работы программы timeout, а второе - время между отдельными запросами в микросекундах interval.

Необходимо реализовать упрощённый аналог утилиты ping, которая определяет доступность удаленного хоста, используя протокол ICMP.

Программа должна последовательно отправлять echo-запросы к указанному адресу и подсчитывать количество успешных ответов. Между запросами, во избежание большой нагрузки на сеть, необходимо выдерживать паузу в interval микросекунд (для этого можно использовать функцию usleep).

Через timeout секунд необходимо завершить работу, и вывести на стандартный поток вывода количество полученных ICMP-ответов, соответствующих запросам.

В качестве аналога можно посмотреть утилиту /usr/bin/ping.

Указания: используйте инструменты ping и wireshark для того, чтобы исследовать формат запросов и ответов. Для того, чтобы выполняемый файл мог без прав администратора взаимодействовать с сетевым интерфейсом, нужно после компиляции установить ему capabilities командой: setcap cat_net_raw+eip PROGRAM. Контрольная сумма для ICMP-заголовков вычисляется по алгоритму из [RFC-1071](http://www.faqs.org/rfcs/rfc1071.html "Перейти"). 
___
## Problem inf-II-07-0: highload/epoll-read-fds-vector

Реализуйте функцию с сигнатурой:

    extern size_t
    read_data_and_count(size_t N, int in[N])
        

которая читает данные из файловых дескрипторов in[X] для всех 0 ≤ X < N , и возвращает суммарное количество прочитанных байт из всех файловых дескрипторов.

Скорость операций ввода-вывода у файловых дескрипторов - случайная. Необходимо минимизировать суммарное астрономическое время чтения данных.

По окончании чтения необходимо закрыть все файловые дескрипторы.

Указание: используйте неблокирующий ввод-вывод. Для тестирования можно использовать socketpair.
___
## Problem inf-II-07-1: highload/epoll-read-write-socket

Программе задается единственный аргумент - номер TCP-порта.

Необходимо принимать входящие соединения на TCP/IPv4 для сервера localhost, читать данные от клиентов в текстовом виде, и отправлять их обратно в текстовом виде, заменяя все строчные буквы на заглавные. Все обрабатываемые символы - из кодировки ASCII.

Одновременных подключений может быть много. Использовать несколько потоков или процессов запрещено.

Сервер должен корректно завершать работу при получении сигнала SIGTERM.

Указание: используйте неблокирующий ввод-вывод.