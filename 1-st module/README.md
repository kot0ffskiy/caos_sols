## Problem inf-I-01-0: shell_automation/sh/find_c_includes

Реализуйте скрипт для командного интерпретатора bash, который выполняет поиск имен #include-файлов для заданных имен Си-функций, используя в качестве источника данных третий раздел man-страниц Linux.

В переменной окружения MANPATH перечислены директории, разделённые символом : (аналогично переменной PATH). В этих директориях располагается каталог man3, устроенный аналогично /usr/share/man/man3. Ответ должен быть составлен с использованием этих директорий, использование man и manpath запрещено.

Файлы могут быть как сжатыми утилитой gz, так и распакованными.

Список функций задается на стандартном потоке ввода:

` fopen
malloc
unknown_function
strcmp `

Если описание функции не найдено, то записывается прочерк из трех дефисов: ---.

Результат необходимо записать в стандартный поток вывода:

`stdio.h
stdlib.h`
\---
`string.h `

В скрипте допускается использовать только команды ввода-вывода и утилиты sed и gunzip.

Использовать вызов интерпретаторов высокоуровневых языков (Perl, Python и пр.) запрещено.
___

## Problem inf-I-01-1: shell_automation/sh/gauss

Реализуйте программу для командного интерпретатора bash, которая вычисляет вещественные корни системы линейных алгебраических уравнений методом Гаусса.

Единственным аргументом скрипта является csv-файл c матрицей (N,N+1) вида:

    2,1,-1,8
    -3,-1,2,-11
    -2,1,2,-3

Скрипт должен вычислить значения и вывести их в тектовом виде на экран в виде строк со значениями:

    .00000000000000000000
    3.00000000000000000000
    -1.00000000000000000000

В скрипте допускается использовать только команды ввода-вывода и утилиту bc (для вещественнозначных вычислений).

Использовать вызов интерпретаторов высокоуровневых языков (Perl, Python и пр.) запрещено.
___

## Problem inf-I-02-0: simulation/alu-sum

Реализуйте функцию с прототипом:

    #include <stdint.h>

    extern void sum(ITYPE first, ITYPE second, ITYPE *res, int *CF);
    

в которой ITYPE - это произвольный беззнаковый целочисленный тип данных с неизвестной разрядностью.

Функция должна вычислить сумму значений first и second, результат записать по указателю в выходной параметр res. При возникновении целочисленного переполнения необходимо в выходной параметр CF записать значение 1, в противном случае - значение 0.

Используйте побитовые операции для вычислений. Операции сложения и вычитания допускаются только применительно к переменным цикла.

На сервер необходимо отправить исходный файл, содержащий только реализацию требуемой функции. Для успешной компиляции и тестирования можно использовать следующий ключ компиляции, задающий требуемый тип: -DITYPE=uint64_t.
___

## Problem inf-I-02-1: simulation/alu-mul

Реализуйте функцию с прототипом:

    #include <stdint.h>

    extern void mul(ITYPE first, ITYPE second, ITYPE *res, int *CF);
    

в которой ITYPE - это произвольный беззнаковый целочисленный тип данных с неизвестной разрядностью.

Функция должна вычислить произведение значений first и second, результат записать по указателю в выходной параметр res. При возникновении целочисленного переполнения необходимо в выходной параметр CF записать значение 1, в противном случае - значение 0. В случае переполнения результат умножения считается не определенным, то есть его значение может быть любым.

Используйте побитовые операции для вычислений. Операции сложения и вычитания допускаются только применительно к переменным цикла.

На сервер необходимо отправить исходный файл, содержащий только реализацию требуемой функции. Для успешной компиляции и тестирования можно использовать следующий ключ компиляции, задающий требуемый тип: -DITYPE=uint64_t.
___
## Problem inf-I-02-2: generic/ieee754/classify

Реализуйте функцию с прототипом:

    typedef enum {
        PlusZero      = 0x00,
        MinusZero     = 0x01,
        PlusInf       = 0xF0,
        MinusInf      = 0xF1,
        PlusRegular   = 0x10,
        MinusRegular  = 0x11,
        PlusDenormal  = 0x20,
        MinusDenormal = 0x21,
        SignalingNaN  = 0x30,
        QuietNaN      = 0x31
    } float_class_t;

    extern float_class_t
    classify(double *value_ptr);
      

которая классифицирует специальные значения вещественного числа, на которое указывает value_ptr, в соответствии со стандартом IEEE 754.

При решении допускается использовать только побитовые операции, включая сдвиги.
___
## Problem inf-I-02-3: c/ints/bitset-calc

Реализуйте калькулятор выражений над множествами в обратной польской записи.

На стандартном потоке ввода задается последовательность, состоящая из символов-значений, и символов-операций.

Значениями являются цифры от 0 до 9, и буквы английского алфавита (заглавные и строчные). Последовательности значений кодируют множества из 62 элементов.

Операциями являются:

    & - пересечение множеств;
    | - объединение множеств;
    ^ - симметрическая разность;
    ~ - дополнение текущего результата до полного множества.

В начальный момент времени, множество-результат является пустым. При чтении символов со стандартного потока ввода, когда встречается символ операции, то эта операция применяется к множеству-результату и последнему прочитанному множеству (как в обратной польской записи).

Вывести на экран полученное итоговое значение множества в нормализованной форме: сначала цифры, затем заглавные буквы, потом - строчные (упорядоченные по алфавиту).

Для хранения множеств использовать, суммарно, не более 16 байт памяти.
### Examples
**Input**

    fed|cba|

**Output**

    abcdef
___
## Problem inf-I-03-0: asm-arm/basics/expression-64

Реализуйте на языке ассемблера armv8 (AArch64) функцию с меткой f, которая вычисляет значение выражения y=Ax2+Bx+C

Значения A, B, C и x хранятся, соответсвенно, в регистрах x0, x1, x2 и x3.

Результат вычисления выражения сохраните в регистре x0.

Все аргументы и значение выражения представимы 64-разрядными знаковыми целыми числами.

Использовать оперативную память запрещено, - можно использовать только регистры.
___
## Problem inf-I-03-1: asm-arm/basics/memaccess-64

Реализуйте на языке ассемблера armv8 (AArch64) функцию с сигнатурой:

    int sum(int x0, size_t N, int *X)

Функция должна вычислять значение x0+∑xi, где 0≤i<N

Обратите внимание на то, что тип int имеет размер 32 бит, а тип size_t - 64 бит.
___
## Problem inf-I-03-2: asm-arm/basics/eqsolution-64

Реализуйте на языке ассемблера armv8 (AArch64) функцию solve, с прототипом

    int solve(int64_t A, int B, int C, int D);
      

которая находит минимальное значение x ∈[0,254], которое является одним из корней уравнения: Ax3+Bx2+Cx+D=0.

Все аргументы и значение выражения представимы 32-разрядными знаковыми целыми числами.

Гарантируется, что на тестовых данных существует целочисленное решение.
___
## Problem inf-I-04-0: asm-arm/basics/globalvars-64

Реализуйте на языке ассемблера armv8 (AArch64) функцию calculate, которая вычисляет значение выражения: R = ( A * B ) + ( C * D ), где A, B, C, и D - это глобальные переменные типа uint64_t, объявленные во внешнем модуле компиляции, а R, - глобальная переменная типа uint64_t в текущем модуле компиляции.
___
## Problem inf-I-04-1: asm-arm/basics/format_io-64

Реализуйте программу на языке ассемблера armv8 (AArch64), которая вычисляет сумму двух целых 32-битных десятичных чисел.

Можно использовать функции стандартной библиотеки языка Си scanf и printf.

В качестве точки входа можно считать функцию main.
___
## Problem inf-I-04-2: asm-arm/basics/char-filter-digits-64

Напишите программу на языке ассемблера armv8 (AArch64), которая читает со стандартного потока ввода последовательность символов, и выводит только те из них, которые являются десятичными цифрами от 0 до 9.

Можно использовать функции стандартной библиотеки языка Си: getchar_unlocked и putchar_unclocked.

В качестве точки входа можно считать функцию main.
___
## Problem inf-I-04-3: asm-arm/basics/reverse-print-chars-64

Реализуйте программу на языке ассемблера armv8 (AArch64), которая считывает символы со стандартного потока ввода, а затем выводит их в обратном порядке.

Можно использовать функции стандартной библиотеки языка Си: fgetc, fputc, getchar_unlocked, putchar_unlocked, realloc и free.

В качестве точки входа можно считать функцию main.
___
## Problem inf-I-05-0: asm-x86/basics-64

Реализуйте на языке ассемблера x86-64 функцию с сигнатурой:

    extern int *A;

    void very_important_function(size_t N);

      

Эта функция должна в цикле N раз:

1. вводит с клавиатуры знаковое целое 32-битное число;
2. умножает его на текущий элемент массива A;
3. выводит результат на экран.

Используйте спецификатор lld при выводе числа. Числа в выводе должны быть разделены переводом строки.
___
## Problem inf-I-05-1: asm-x86/arrays-64

Реализуйте функцию на языке ассемблера x86-64 с сигнатурой:

    extern void sum(size_t N, const int *A, const int *B, int *R);

Функция вычисляет значения Ri=Ai+Bi для всех i от 0 до N.

Память для хранения массива-результата уже выделена.
___
## Problem inf-I-06-0: asm-x86/avx/intro-64

Реализуйте на языке ассемблера x86-64 функцию с сигнатурой:

    extern double very_important_function(size_t N, const float *A, const float *B, float *R);

Функция вычисляет:

- поэлементную сумму R[i]=A[i]+B[i];
- среднее арифметическое всех значений R[i], которое является возвращаемым результатом функции.

Гарантируется, что число N больше нуля и кратно 8, а адреса массивов выровнены в памяти по границе 32 байта. Используйте векторные инструкции для вычисления. 
___
## Problem inf-I-06-1: asm-x86/avx/sin-64

Реализуйте на языке ассемблера x86-64 функцию с сигнатурой:

    extern double avx_sin(double x)

которая вычисляет значение sin(x).

Используйте набор команд AVX, а не SSE.

Запрещено использовать встроенные тригонометрические инструкции.

Для вычислений используйте известный вам из курса Математического анализа способ разложения функции в ряд. Точность результата должна быть маскимально возможной для типа данных double. 
___
## Problem inf-I-06-2: asm-x86/avx/dot-product-64

Реализуйте на языке ассемблера x86-64 функцию с сигнатурой:

    extern float dot_product(size_t N, const float *A, const float *B);

которая вычисляет скалярное произведение векторов A и B.

Гарантируется, что N больше нуля, но не гарантируется, что N кратно восьми.

Значения исходных векторов хранятся в произвольных адресах памяти, поэтому выравнивание для них не гарантируется.

Необходимо минимизировать количество выполняемых вычислительных инструкций, используя векторные вычисления. Доступен набор команд AVX.