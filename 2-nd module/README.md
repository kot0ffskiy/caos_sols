## Problem inf-I-07-0: posix/syscalls/hello-world

Реализуйте на языке Си программу, которая выводит "Hello, World!".

Использование стандартной библиотеки Си запрещено, единственная доступная функция - это syscall(2).

Точка входа в программу - функция _start.

Для использования syscall можно включить в текст программы следующее объявление:

    long syscall(long number, ...);
___
## Problem inf-I-07-1: posix/syscalls/copy-stream

Реализуйте на языке Си программу, которая копирует содержимое потока ввода на поток вывода.

Использование стандартной библиотеки Си запрещено, единственная доступная функция - это syscall(2).

Точка входа в программу - функция _start.

Для использования syscall можно включить в текст программы следующее объявление:

    long syscall(long number, ...);
___
## Problem inf-I-07-2: asm-x86/syscalls/copy-stream

Реализуйте на языке ассемблера x86_64 программу, которая копирует содержимое со стандартного потока ввода на стандартный поток вывода.

Использование стандартной библиотеки Си запрещено.

Точка входа в программу - функция _start.
___
## Problem inf-I-07-3: asm-x86/syscalls/reverse-print-lines

Реализуйте на языке ассемблера x86_64 программу, которая читает со стандартного потока ввода текст, после чего выводит все строки текста в обратном порядке.

Использование стандартной библиотеки Си запрещено.

Точка входа в программу - функция _start.

Файл может не содержать перевода строки в конце.
### Examples
__Input__

    Мой дядя самых честных правил,
    Когда не в шутку занемог,
    Он уважать себя заставил
    И лучше выдумать не мог.
      

__Output__

    И лучше выдумать не мог.
    Он уважать себя заставил
    Когда не в шутку занемог,
    Мой дядя самых честных правил,
___
## Problem inf-I-08-0: files-io/read-filter-write

Программе в аргументах командной строки передаются три имени файла. Первый аргумент - входной файл, два остальных - выходные.

Реализуйте программу, которая читает символы из первого файла, во второй файл записывает только цифры, а в третий - всё остальное.

Разрешается использовать только низкоуровневый ввод-вывод POSIX.

Если входной файл не существует, то нужно завершить работу с кодом 1.

Если не возможно создать один из выходных файлов, то завершить работу с кодом 2.

При возникновении других ошибок ввода-вывода - завершить работу с кодом 3.
___
## Problem inf-I-08-1: files-io/print-list-posix

Программе в аргументе командной строки передается имя файла с бинарными данными в Little-Endian.

Файл хранит внутри себя односвязный список элементов:

    struct Item {
    int value;
    uint32_t next_pointer;
    };

Поле value храние значение элемента списка, поле next_pointer - позицию в файле (в байтах), указывающую на следующий элемент. Признаком последнего элемента является значение next_pointer, равное 0.

Расположение первого элемента списка (если он существует) - строго в нулевой позиции в файле, расположение остальных - случайным образом.

Выведите на экран через пробел значения элементов в списке в текстовом представлении.

Для работы с файлом использовать только низкоуровневый ввод-вывод POSIX.
___
## Problem inf-I-08-3: files-io/print-list-winapi

Задача, аналогичная print-list-posix, но требуется решение под Windows.

Программе в аргументе командной строки передается имя файла с бинарными данными в Little-Endian.

Файл хранит внутри себя односвязный список элементов:

    struct Item
    {
    int value;
    uint32_t next_pointer;
    };

Поле value храние значение элемента списка, поле next_pointer - позицию в файле (в байтах), указывающую на следующий элемент. Признаком последнего элемента является значение next_pointer, равное 0.

Расположение первого элемента списка (если он существует) - строго в нулевой позиции в файле, расположение остальных - случайным образом.

Выведите на экран значения элементов в списке в текстовом представлении.

Для работы с файлом использовать только низкоуровневый ввод-вывод WinAPI.
___
## Problem inf-I-09-0: posix/filesystem/file-list-summ-size

Программе на стандартном потоке ввода передаётся список имён файлов.

Необходимо посчитать суммарный размер в байтах всех файлов, которые являются регулярными.
___
## Problem inf-I-09-1: posix/filesystem/find-invalid-executables

Программе на стандартном потоке ввода передаётся список имён файлов.

Необходимо вывести на стандартный поток вывода имена "неправильных" выполняемых файлов, то есть файлов, которые отмечены как исполняемые, но при этом они заведомо не могут быть выполнены в системе (не начинаются с корректной строки #!, содержащей запускаемый интерпретатор, и не являются ELF-файлами).
___
## Problem inf-I-09-2: c/texts/normalize-path

Реализуйте функцию

    extern void normalize_path(char * path);

которая обрабатывает строки, представляющие пути к файлам (заканчиваются на любой символ, отличный от /) или каталогам (заканчиваются на символ /).

Функция должна привести текст в каноническую форму:

1. убрать дублирование подряд идущих символов /
2. обработать фрагменты ./ и ../

Запрещается использовать библиотечные строковые функции.

Запрещается выделять память под новую строку, - используйте уже существующую, аргумент не является константной строкой.

Используйте арифметику указателей; запрещается обращение к символам как к элементам массива.
### Examples
__Input__

    abrakadabra///abc

__Output__

    abrakadabra/abc

__Input__

    /var/log/../lib/./ejexec

__Output__

    /var/lib/ejexec

___
## Problem inf-I-09-3: posix/filesystem/manage-symlinks

Программе на стандартном потоке ввода передаётся список имён файлов.

Если файл является символической ссылкой, то нужно вывести абсолютное имя того файла, на который эта ссылка указывает.

Если файл является регулярным, то необходимо создать символическую ссылку в текущем каталоге, приписав в названии файла префикс link_to_.
___
## Problem inf-I-10-0: posix/mmap/find-substrings-in-file

Программе передаются два аргумента: имя файла, и текстовая строка для поиска.

Необходимо найти все вхождения строки в бинарном файле, используя отображение на память с помощью системного вызова mmap.

На стандартный поток вывода вывести список всех позиций (с нуля) в файле, где втречаются строка.
___
## Problem inf-I-10-1: posix/mmap/print-list-using-mmap

Программе в аргументе командной строки передается имя файла с бинарными данными в Little-Endian.

Файл хранит внутри себя односвязный список элементов:

    struct Item {
    int value;
    uint32_t next_pointer;
    };

Поле value храние значение элемента списка, поле next_pointer - позицию в файле (в байтах), указывающую на следующий элемент. Признаком последнего элемента является значение next_pointer, равное 0.

Расположение первого элемента списка (если он существует) - строго в нулевой позиции в файле, расположение остальных - случайным образом.

Выведите на экран значения элементов в списке в текстовом представлении.

Используйте отображение содержимого файла на память.
___
## Problem inf-I-10-2: posix/mmap/make-spiral-file

Программе передаются три аргумента: имя файла, положительное целое число N - размер квадратной матрицы, и положительное число W - ширина клетки матицы в символах.

Необходимо в указанном файле сформировать текст, который содержит матрицу, состоящую из чисел от 1 до N2, таким образом, чтобы числа заполняли её по спирали, по часовой стрелке.

Числа должны быть выровнены по правой границе ячейки матрицы.

Используйте mmap для записи в файл.

Можно использовать функции форматного вывода для преобразования числа в строку.
### Examples
__Input__

    ./solution out.txt 5 5

__Output in out.txt__

     1    2    3    4    5
    16   17   18   19    6
    15   24   25   20    7
    14   23   22   21    8
    13   12   11   10    9
___
## Problem inf-I-11-0: posix/fork/test-proc-limit

Определите экспериментальным способом, какое максимальное колчичество процессов можно запустить с установленными в ejudge лимитами.

Запрещается использовать getrlimit, и другие явные способы определения ограничений.
___
## Problem inf-I-11-1: posix/fork/proc-print-numbers

Программе передается аргумент - целое число N > 0.

Необходимо создать N-1 дополнительных процессов таким образом, чтобы у каждого процесса было не более одного дочернего процесса.

Каждый из процессов должен вывести на стандартный поток ввода ровно одно число таким образом, чтобы вы выходе получилась строка:

    1 2 3 4 ... N

__Внимание!__ В этой задаче будет сравнение с учетом пробельных символов. Между числами должен быть ровно один пробел, а завершается строка символом перевода строки.
___
## Problem inf-I-11-2: posix/fork/proc-count-words

На стандартном потоке ввода задается строка текста, которая состоит слова (последовательности непробельных символов), между которыми может быть произвольное количество пробельных символов, включая перевод строки.

Необходимо посчитать количество слов, если известно, что их не больше, чем 255, и вывести это значение на стандартный поток вывода.

Используйте создание новых процессов таким образом, чтобы каждый процесс читал не более одного слова, например, c помощью scanf("%s", ...).

Вывод результата возможен только из того процесса, который запущен самым первым (т.е. из исходной программы).

Итоговая программа должна вернуться с кодом возврата 0.

Размер каждого слова не превышает 4096 байт.
___
## Problem inf-I-12-0: posix/exec/exec-python

Программе на стандартный поток ввода задается некоторое арифметическое выражение в синтаксисе языка python3.

Необходимо вычислисть это выражение, и вывести результат.

Использовать дополнительные процессы запрещено.
___
## Problem inf-I-12-1: posix/exec/exec-gcc

Программе на стандартном потоке ввода задается выражение в синтаксисе языка Си.

Необходимо вычислить значение этого выражения (итоговый результат представим типом int) и вывести его на стандартный поток вывода.
___